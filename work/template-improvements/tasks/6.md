---
status: planned
depends_on: []
files_modified:
  - .claude/skills/error-recovery/SKILL.md
---

# Task 6: Create Error Recovery Skill (Replaces Hooks)

## Description

**CHANGED FROM HOOKS TO SKILL** - Analysis revealed that Claude Code doesn't have a hooks framework for error interception. Instead, we create an error-recovery skill that the orchestrator and other skills can invoke when errors occur.

This skill provides structured recovery patterns for common failure scenarios.

## Why Skill Instead of Hooks

1. ❌ Hooks can't intercept tool errors (no framework)
2. ❌ Bash scripts don't work reliably on Windows
3. ❌ Can't inject recovery logic into tool execution
4. ✅ Skills can be invoked when error detected
5. ✅ Orchestrator can check for errors and invoke recovery
6. ✅ Other skills can reference recovery patterns

## What to do

### Create `.claude/skills/error-recovery/SKILL.md`:

```markdown
---
name: error-recovery
version: 1.0.0
description: Structured recovery patterns for common error scenarios
triggers:
  - Edit tool fails
  - Bash command times out
  - Test command fails
  - Any unexpected error
---

# Error Recovery Skill

## Purpose

Provide structured recovery patterns when errors occur during execution. This skill doesn't automatically intercept errors — it must be invoked by orchestrator or other skills when they detect failures.

## When to Invoke

Invoke this skill when:
1. Edit tool returns error (file not found, permission denied, old_string not found)
2. Bash command times out or returns non-zero exit code
3. Test command fails (pytest, jest, etc.)
4. Unexpected error during task execution

## Recovery Patterns

### Pattern 1: Edit Error Recovery

**Triggers:** Edit tool failure

**Diagnosis:**
```
1. Check error message:
   - "old_string not found" → Content changed since last read
   - "file not found" → Path incorrect or file deleted
   - "permission denied" → File locked or protected

2. Based on diagnosis, apply recovery:
```

**Recovery actions:**

| Error Type | Recovery |
|------------|----------|
| old_string not found | Re-read file, find correct string, retry edit |
| File not found | Verify path with Glob, create if needed |
| Permission denied | Check file status, wait and retry |
| Encoding error | Try different encoding or use Write tool |

**Max retries:** 3

**Escalation:** After 3 retries, report to user:
```
Edit failed after 3 attempts:
- File: [path]
- Error: [error message]
- Attempted: [recovery actions]

Manual intervention required.
```

---

### Pattern 2: Bash Timeout Recovery

**Triggers:** Command exceeds timeout, hangs, or becomes unresponsive

**Diagnosis:**
```
1. Identify command type:
   - Long-running build → May need more time
   - Network request → May be waiting for response
   - Interactive prompt → Needs input (can't provide)
   - Infinite loop → Bug in script

2. Check what command was trying to do
```

**Recovery actions:**

| Scenario | Recovery |
|----------|----------|
| Build command | Retry with longer timeout, or run in background |
| Network request | Check connectivity, retry with timeout |
| Interactive prompt | Modify command to avoid interaction (-y, --yes, etc.) |
| Suspected loop | Kill process, investigate script |

**Max retries:** 2

**Escalation:**
```
Command timed out:
- Command: [command]
- Timeout: [seconds]
- Attempts: [count]

Options:
1. Run in background and check later
2. Modify command (add flags, change parameters)
3. Skip and continue with next task
4. Investigate the issue manually
```

---

### Pattern 3: Test Failure Recovery

**Triggers:** Test command returns failures

**CRITICAL:** This pattern triggers `systematic-debugging` skill.

**Diagnosis:**
```
1. Parse test output:
   - How many tests failed?
   - Which tests failed?
   - What's the failure message?
   - Is it assertion error or exception?

2. Check if related to recent changes:
   - Did we modify code that these tests cover?
   - Are these new tests or existing?
```

**Recovery flow:**
```
Test Failure Detected
    ↓
Parse failure output
    ↓
Load systematic-debugging skill (REQUIRED)
    ↓
Phase 1: Root cause investigation
    ↓
DO NOT propose fixes until Phase 1 complete
    ↓
After root cause identified:
    - If our code bug → fix using TDD
    - If test bug → fix test
    - If flaky test → use condition-based-waiting skill
    - If environment issue → document and skip
```

**Never:**
- Propose fix without understanding root cause
- Skip failing tests without documentation
- Assume test is wrong without investigation

---

### Pattern 4: General Error Recovery

**Triggers:** Any unexpected error not covered above

**Diagnosis:**
```
1. Capture error details:
   - Error message
   - Stack trace (if available)
   - Context (what were we trying to do)
   - Previous successful operations

2. Categorize:
   - Transient (network, timeout) → Retry
   - Permanent (logic error, missing dependency) → Fix
   - Unknown → Investigate
```

**Recovery actions:**

| Category | Recovery |
|----------|----------|
| Transient | Wait 5 seconds, retry once |
| Permanent | Stop current task, report issue |
| Unknown | Gather more info, ask user |

**Escalation:**
```
Unexpected error occurred:
- Context: [what we were doing]
- Error: [error details]
- Category: [transient/permanent/unknown]

Recommendation: [suggested action]

Proceed with recommendation? [Y/n]
```

## Integration with Orchestrator

Orchestrator should:
1. Wrap tool calls in error checking
2. When error detected → invoke error-recovery skill
3. Follow recovery pattern for error type
4. Track retry counts per error
5. Escalate to user if max retries exceeded

```
try_tool_call(tool, params):
    result = call_tool(tool, params)

    IF result.error:
        recovery = invoke_skill("error-recovery", {
            "error_type": classify_error(result.error),
            "context": current_task,
            "retry_count": get_retry_count()
        })

        IF recovery.action == "retry":
            increment_retry_count()
            return try_tool_call(tool, recovery.modified_params)

        IF recovery.action == "escalate":
            return ask_user(recovery.escalation_message)

        IF recovery.action == "skip":
            log_skipped_error(result.error)
            return null

    return result
```

## State Tracking

Track errors in STATE.md under "## Errors Encountered":

```markdown
## Errors Encountered

| Time | Error Type | Context | Recovery | Result |
|------|------------|---------|----------|--------|
| 10:00 | Edit old_string not found | Task 1 | Re-read and retry | Resolved |
| 10:15 | Test failure | Task 2 | systematic-debugging | Investigating |
```

## Output Format

```json
{
  "errorType": "edit_failure|bash_timeout|test_failure|general",
  "diagnosis": "old_string not found - file content changed",
  "recoveryAction": "retry|escalate|skip|invoke_skill",
  "modifiedParams": { ... },
  "retryCount": 1,
  "maxRetries": 3,
  "escalationMessage": "..."
}
```
```

## Acceptance Criteria

- [ ] Skill file exists at .claude/skills/error-recovery/SKILL.md
- [ ] All 4 recovery patterns documented (edit, bash, test, general)
- [ ] Each pattern has diagnosis, actions, max retries, escalation
- [ ] Test failure pattern triggers systematic-debugging
- [ ] Integration with orchestrator documented
- [ ] State tracking format defined
- [ ] Output format specified (JSON)

## Context Files

**Required:**
- `.claude/skills/systematic-debugging/SKILL.md` (for test failure pattern)
- `.claude/skills/methodology/SKILL.md` (skill pattern reference)
- `CLAUDE.md` (error handling rules)

## Technical Details

**Files:**
- `.claude/skills/error-recovery/SKILL.md` - Create new

**No bash dependencies** - pure skill approach
**Cross-platform** - works on Windows, Mac, Linux

**Edge cases:**
- Multiple errors in sequence → Track each, don't flood user
- Error during recovery → Escalate immediately
- Same error repeating → Detect pattern, try different approach
- Critical error (data loss risk) → Stop immediately, preserve state
